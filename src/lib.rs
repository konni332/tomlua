use std::path::{Path, PathBuf};

use mlua::Lua;
use mlua::Value;
use serde::{Deserialize, Serialize};

pub mod error;

// reexports
pub use tomlua_macros::TomluaExecute;
pub use tomlua_macros::tomlua_config;

use crate::error::lua_error_message;

// scripts

/// Represents a single executable Lua script entry within a TOML configuration.
///
/// A `Script` can be defined either inline (directly embedded Lua code)
/// or as a path reference to an external `.lua` file.  
/// If both `inline` and `path` are present, **`inline` takes precedence**.
///
/// This struct is designed to be deserialized from TOML using [`serde`],
/// and is compatible with the [`mlua`](https://docs.rs/mlua) runtime through its
/// [`LuaUserData`] and [`FromLua`] implementations.
///
///
/// # Structure
///
/// ```toml
/// [[scripts]]
/// name = "example"
/// path = "./scripts/example.lua"
///
/// [[scripts]]
/// name = "inline_test"
/// inline = """
/// print("Hello from inline Lua!")
/// """
/// ```
///
/// # Behavior
///
/// - `inline` and `path` are **mutually exclusive**, but both can technically exist.
///   When both are defined, the inline version will be executed.
/// - Scripts are typically executed using the methods generated by
///   [`#[derive(TomluaExecute)`](crate::TomluaExecute) or the
///   [`#[tomlua_config]`](crate::tomlua_config) macro.
///
/// # Example
///
/// ```rust
/// use tomlua::Script;
///
/// let script = Script {
///     name: "init".to_string(),
///     path: Some("./init.lua".into()),
///     inline: None,
/// };
///
/// assert_eq!(script.name(), "init");
/// assert!(script.path().is_some());
/// ```
///
/// When deserialized from TOML:
///
/// ```toml
/// [[scripts]]
/// name = "startup"
/// inline = "print('Booting up!')"
/// ```
///
/// The above entry will deserialize into a `Script` with `name = "startup"`
/// and `inline = Some("print('Booting up!')")`.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Script {
    /// The unique name of the script. Used for referencing scripts programmatically.
    name: String,

    /// Optional filesystem path to a Lua script file.
    ///
    /// When set, this path will be read at runtime and its contents executed
    /// through the `mlua` interpreter.
    path: Option<PathBuf>,

    /// Optional inline Lua source code.
    ///
    /// This field allows embedding Lua directly into the TOML configuration.
    /// If both `inline` and `path` are specified, this field takes precedence.
    inline: Option<String>,
}

impl Script {
    /// Creates a new, empty [`Script`] instance with default values.
    ///
    /// - `name` is an empty string.
    /// - `path` is `None`.
    /// - `inline` is an empty `Some("")` value.
    ///
    /// This is primarily useful for creating placeholder or test scripts.
    ///
    /// # Example
    /// ```
    /// use tomlua::Script;
    ///
    /// let s = Script::new();
    /// assert_eq!(s.name(), "");
    /// assert!(s.path().is_none());
    /// ```
    pub fn new() -> Self {
        Script {
            name: "".into(),
            path: None,
            inline: Some("".into()),
        }
    }

    /// Returns the filesystem path of the script, if any.
    ///
    /// This method returns a reference to the underlying [`PathBuf`]
    /// wrapped in an [`Option`].
    ///
    /// # Example
    /// ```
    /// # use tomlua::Script;
    /// # use std::path::Path;
    /// let s = Script {
    ///     name: "file_script".to_string(),
    ///     path: Some("./foo.lua".into()),
    ///     inline: None,
    /// };
    ///
    /// assert_eq!(s.path().unwrap(), Path::new("./foo.lua"));
    /// ```
    pub fn path(&self) -> Option<&PathBuf> {
        self.path.as_ref()
    }

    /// Returns the inline Lua source code, if present.
    ///
    /// # Example
    /// ```
    /// # use tomlua::Script;
    /// let s = Script {
    ///     name: "inline_test".into(),
    ///     path: None,
    ///     inline: Some("print('hi')".into()),
    /// };
    ///
    /// assert_eq!(s.inline().unwrap(), "print('hi')");
    /// ```
    pub fn inline(&self) -> Option<&String> {
        if let Some(inline) = &self.inline
            && inline.is_empty()
        {
            return None;
        }
        self.inline.as_ref()
    }

    /// Returns the name of the script as a string slice.
    ///
    /// This is used to identify and reference scripts programmatically.
    ///
    /// # Example
    /// ```
    /// # use tomlua::Script;
    /// let s = Script {
    ///     name: "boot".into(),
    ///     path: None,
    ///     inline: None,
    /// };
    ///
    /// assert_eq!(s.name(), "boot");
    /// ```
    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn validate(&self) -> Result<(), crate::error::Error> {
        match self.inline() {
            Some(inline) => return self.validate_inline(&inline),
            None => {}
        }
        match self.path() {
            Some(path) => Self::validate_path(path),
            None => Err(crate::error::Error::EmptyScript(self.name().to_string())),
        }
    }
    fn validate_path<P: AsRef<Path>>(path: P) -> Result<(), crate::error::Error> {
        if !path.as_ref().exists() {
            return Err(crate::error::Error::InvalidPath(
                path.as_ref().to_string_lossy().to_string(),
            ));
        }
        Ok(())
    }
    fn validate_inline(&self, inline: &str) -> Result<(), crate::error::Error> {
        let lua = Lua::new();
        lua.load(inline).into_function().map_err(|error| {
            let error = lua_error_message(&error);
            crate::error::Error::InvalidInline {
                error,
                script: self.name().to_string(),
            }
        })?;
        Ok(())
    }
}

impl mlua::prelude::LuaUserData for Script {
    /// Exposes getters and setters to the Lua runtime, allowing Lua scripts
    /// to read and modify `Script` properties at runtime.
    ///
    /// # Exposed Methods
    ///
    /// **Getters**
    /// - `name()` → `string`
    /// - `path()` → `string?`
    /// - `inline()` → `string?`
    ///
    /// **Setters**
    /// - `set_name(name: string)`
    /// - `set_path(path: string?)`
    /// - `set_inline(code: string?)`
    ///
    /// # Example (Lua)
    ///
    /// ```lua
    /// print(script:name())
    /// script:set_name("updated")
    /// script:set_inline("print('modified inline code')")
    /// ```
    fn add_methods<M: mlua::UserDataMethods<Self>>(methods: &mut M) {
        // getter
        methods.add_method("name", |_, this, ()| Ok(this.name.clone()));
        methods.add_method("path", |_, this, ()| {
            Ok(this.path().map(|p| p.display().to_string()))
        });
        methods.add_method("inline", |_, this, ()| {
            Ok(this.inline().map(|s| s.to_string()))
        });

        // setter
        methods.add_method_mut("set_name", |_, this, name: String| {
            this.name = name;
            Ok(())
        });
        methods.add_method_mut("set_path", |_, this, path: Option<String>| {
            this.path = match path {
                Some(p) => Some(PathBuf::from(p)),
                None => None,
            };
            Ok(())
        });
        methods.add_method_mut("set_inline", |_, this, inline: Option<String>| {
            this.inline = inline;
            Ok(())
        });
    }
}

impl mlua::prelude::FromLua for Script {
    /// Allows conversion from Lua values to a [`Script`] instance.
    ///
    /// This enables passing Lua tables or userdata directly into Rust functions
    /// expecting a `Script`, for example when dynamically generating or modifying
    /// scripts from Lua.
    ///
    /// # Accepted Lua Types
    ///
    /// - **Table:** Must contain at least a `"name"` key.
    ///   Optionally supports `"path"` and `"inline"`.
    /// - **UserData:** If the Lua value already wraps a `Script`, it is cloned.
    ///
    /// Any other Lua value will result in a conversion error.
    ///
    /// # Errors
    ///
    /// Returns [`mlua::Error::FromLuaConversionError`] if the input type is not
    /// a table or `Script` userdata, or if required fields are missing.
    fn from_lua(value: mlua::Value, _lua: &mlua::Lua) -> mlua::Result<Self> {
        match value {
            Value::Table(table) => {
                let name: String = table.get("name")?;
                let path: Option<String> = table.get("path").unwrap_or(None);
                let path: Option<PathBuf> = match path {
                    Some(p) => Some(PathBuf::from(p)),
                    None => None,
                };
                let inline: Option<String> = table.get("inline").unwrap_or(None);
                Ok(Script { name, path, inline })
            }
            Value::UserData(ud) => {
                let script: Script = ud.borrow::<Script>()?.clone();
                Ok(script)
            }
            other => Err(mlua::Error::FromLuaConversionError {
                from: other.type_name(),
                to: "Script".into(),
                message: Some("expected table or userdata".into()),
            }),
        }
    }
}
